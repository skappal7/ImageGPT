# -*- coding: utf-8 -*-
"""ImageGPT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13EToSk1QcF1khImZJuaYbS_IZsuevmS5
"""


import streamlit as st
import base64
import os
import uuid
import cv2
import numpy as np
import requests

MARKDOWN = """
# WebcamGPT ðŸ’¬ + ðŸ“¸

webcamGPT is a tool that allows you to chat with video using OpenAI Vision API.

Visit [awesome-openai-vision-api-experiments](https://github.com/roboflow/awesome-openai-vision-api-experiments)
repository to find more OpenAI Vision API experiments or contribute your own.
"""
AVATARS = (
    "https://media.roboflow.com/spaces/roboflow_raccoon_full.png",
    "https://media.roboflow.com/spaces/openai-white-logomark.png"
)


def preprocess_image(image: np.ndarray) -> np.ndarray:
    # Ensure the image has at least 2 dimensions
    if len(image.shape) < 2:
        raise ValueError("Input must be >= 2-d.")
    
    # If the image is 1-dimensional, reshape it to (1, N)
    if len(image.shape) == 1:
        image = np.reshape(image, (1, -1))

    # Flip left-right
    image = np.fliplr(image)

    # Convert color space
    return cv2.cvtColor(image, cv2.COLOR_RGB2BGR)


def encode_image_to_base64(image: np.ndarray) -> str:
    success, buffer = cv2.imencode('.jpg', image)
    if not success:
        raise ValueError("Could not encode image to JPEG format.")

    encoded_image = base64.b64encode(buffer).decode('utf-8')
    return encoded_image


def compose_payload(image: np.ndarray, prompt: str) -> dict:
    base64_image = encode_image_to_base64(image)
    return {
        "model": "gpt-4-vision-preview",
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": prompt
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": f"data:image/jpeg;base64,{base64_image}"
                        }
                    }
                ]
            }
        ],
        "max_tokens": 300
    }


def compose_headers(api_key: str) -> dict:
    return {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }


def prompt_image(api_key: str, image: np.ndarray, prompt: str) -> str:
    headers = compose_headers(api_key=api_key)
    payload = compose_payload(image=image, prompt=prompt)
    response = requests.post(url=API_URL, headers=headers, json=payload).json()

    if 'error' in response:
        raise ValueError(response['error']['message'])
    return response['choices'][0]['message']['content']


def cache_image(image: np.ndarray) -> str:
    image_filename = f"{uuid.uuid4()}.jpeg"
    os.makedirs(IMAGE_CACHE_DIRECTORY, exist_ok=True)
    image_path = os.path.join(IMAGE_CACHE_DIRECTORY, image_filename)
    cv2.imwrite(image_path, image)
    return image_path


def respond(api_key: str, image: np.ndarray, prompt: str, chat_history):
    if not api_key:
        raise ValueError(
            "API_KEY is not set. "
            "Please follow the instructions in the README to set it up.")

    image = preprocess_image(image=image)
    cached_image_path = cache_image(image)
    response = prompt_image(api_key=api_key, image=image, prompt=prompt)
    chat_history.append(((cached_image_path,), None))
    chat_history.append((prompt, response))
    return "", chat_history


def main():
    st.markdown(MARKDOWN)
    api_key = st.text_input("OpenAI API KEY", type="password")
    webcam = st.file_uploader("Upload Image", type=["jpg", "jpeg", "png"])
    prompt = st.text_area("Enter your message:")
    chat_history = []

    if st.button("Submit"):
        if not api_key:
            st.error("API_KEY is not set. Please set it up.")
        elif webcam is None:
            st.error("Please upload an image.")
        else:
            response, chat_history = respond(api_key, np.array(webcam.read()), prompt, chat_history)
            st.success("Response: {}".format(response))

    # Display chat history
    for entry in chat_history:
        if entry[0]:
            for image_path in entry[0]:
                st.image(image_path, use_column_width=True)
        if entry[1]:
            st.text(entry[1])


if __name__ == "__main__":
    main()

